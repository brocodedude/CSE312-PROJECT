<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <script src="https://cdn.socket.io/4.3.1/socket.io.min.js"></script>
    <title>Lets play a game</title>
</head>
<body>
<script>
    const lobbyId = "{{lobby}}";
    const userId = "{{user}}";

    let allPlayers = {};

    const socket = io({transports: ['websocket']});
    let prevGameState;

    // default socket io connection message
    socket.on('connect', () => {
        socket.emit('join', {'lobbyId': lobbyId, 'userId': userId})
        console.log('Connected')
    })

    socket.on('state', function (msg) {
        prevGameState = msg
        // prevGameState = JSON.parse(msg);
        console.log(prevGameState.ghostsEaten)
        // start once all state has been received
        const game = new Phaser.Game(config);
    })

    // actual join with player info
    socket.on('set', function (msg) {
        let json = JSON.parse(msg);
        if (!json.spriteType) {
            throw new Error("No sprite id found")
        }
        allPlayers[json.playerid] = json
        playerSprites[json.spriteType].username = json.user
    })

    socket.on('pos', function (msg) {
        let json = JSON.parse(msg);
        let spriteId = json.spriteType
        // update player
        allPlayers[json.id] = json

        if (playerSprites[spriteId].playerInfo === null) {
            console.log('Client not ready')
            return
        }

        // update other player sprites
        playerSprites[spriteId].playerInfo.x = json.x
        playerSprites[spriteId].playerInfo.y = json.y
        // update other player username text
        setUserNameTextPos(spriteId)

        try {
            playerSprites[spriteId].playerInfo.anims.play(json.spriteAnim, true)
        } catch (e) {
            // if invalid anim default to neutral image
            playerSprites[spriteId][0].anims.play()
        }
    })

    socket.on('dis', function (msg) {
        const json = JSON.parse(msg);
        console.log('disconnect')
        console.log(json.playerid)
        delete allPlayers[json.playerid]
        setUserNameText(json.spriteType, '')
    })

    socket.on('pellet', function (msg) {
        const json = JSON.parse(msg)
        const x = json.x
        const y = json.y
        console.log(`Pellet eaten at x:${x}, y:${y}`)
        pelletLayer.removeTileAt(x, y)
        if (pelletLayer.tilesDrawn === 1) {
            // all pellets eaten
            gameEnd = true
        }
    })

    socket.on('power', function (msg) {
        const json = JSON.parse(msg)
        const x = json.x
        const y = json.y
        console.log(`Pellet eaten at x:${x}, y:${y}`)
        powerLayer.removeTileAt(x, y)
        // give pacman power up
        playerSprites['pcm'].isPoweredUp = 1500
    })

    // pacman dead
    socket.on('pacded', function (msg) {
        if (playerSprites['pcm'].isPoweredUp === 0 || playerSprites['pcm'].isPoweredUp > 1200) {
            console.log('Received pacman is dead')
            playerSprites['pcm'].playerInfo.destroy()
            gameEnd = true
            return
        }

        const spriteId = JSON.parse(msg).id
        if (spriteId !== undefined) {
            playerSprites[spriteId].playerInfo.destroy()
            setUserNameText(spriteId, '')

            if (!playerSprites['gh1'].playerInfo.active
                && !playerSprites['gh2'].playerInfo.active
                && !playerSprites['gh3'].playerInfo.active
            ) {   // all ghosts eaten
                gameEnd = true
            }
            return;
        }
        console.log('Json does not have id')
    })

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // main game

    // helper variables
    let cursors;
    let gameEnd = false
    let gameOverText
    let isRedirecting = true
    // mapped sprite id with:
    // playerInfo
    // default anim
    // anim base so that we can add direction
    // start pos : {x, y}
    /**
     *
     * @type {{gh2: {playerInfo: null, animBase: string, userNameTextPos: null, movementSpeed: number, defaultAnim: string, startPos: number[]}, gh1: {playerInfo: null, animBase: string, userNameTextPos: null, movementSpeed: number, defaultAnim: string, startPos: number[]}, gh3: {playerInfo: null, animBase: string, userNameTextPos: null, movementSpeed: number, defaultAnim: string, startPos: number[]}, pcm: {isPoweredUp: number, playerInfo: null, animBase: string, userNameTextPos: null, movementSpeed: number, defaultAnim: string, startPos: number[]}}}
     */
    const playerSprites = {
        'pcm': {
            playerInfo: null,
            defaultAnim: 'pacmanDefault',
            animBase: 'pacman',
            startPos: [1050, 925],
            userNameTextPos: null,
            isPoweredUp: 0,
            movementSpeed: -200

        },
        'gh1': {
            playerInfo: null,
            defaultAnim: 'ghostRedNorth',
            animBase: 'ghostRed',
            startPos: [670.1666666666666, 424.49999999999994],
            userNameTextPos: null,
            movementSpeed: -160

        },
        'gh2': {
            playerInfo: null,
            defaultAnim: 'ghostBlueNorth',
            animBase: 'ghostBlue',
            startPos: [723.4999999999992, 424.49999999999994],
            userNameTextPos: null,
            movementSpeed: -160
        },
        'gh3': {
            playerInfo: null,
            defaultAnim: 'ghostPinkNorth',
            animBase: 'ghostPink',
            startPos: [776.8333333333, 424.49999999999994],
            userNameTextPos: null,
            movementSpeed: -160

        },
    }

    const userNameOffSetX = 15
    const userNameOffSetY = 35
    // movement

    /**
     *  @type {?Phaser.Tilemaps.TilemapLayer} mapLayer
     */
    let mapLayer
    /**
     *  @type {?Phaser.Tilemaps.TilemapLayer} mapLayer
     */
    let pelletLayer
    /**
     *  @type {?Phaser.Tilemaps.TilemapLayer} mapLayer
     */
    let powerLayer

    const config = {
        type: Phaser.AUTO,
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundColor: 0x000000,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: 0,
            }
        },
        scale: {
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH,
            parent: 'thegame'
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    function preload() {
        // sprite sheets
        this.load.spritesheet("pacman", "assets/pacmanSpriteSheet.png", {
            frameWidth: 50,
            frameHeight: 50,
        });
        this.load.spritesheet("ghosts", "assets/ghosts.png", {
            frameWidth: 50,
            frameHeight: 50,
        });
        this.load.spritesheet("fruits", "assets/fruits.png", {
            frameWidth: 50,
            frameHeight: 50,
        });
        this.load.image('secondTile', 'assets/secondTile.png')
        this.load.image('forthTile', 'assets/forthTile.png')
        this.load.image('centrepoint', 'assets/centrepoint.png')
        this.load.image('power-up', 'assets/powercent.png')

        this.load.tilemapTiledJSON('map', "assets/map.json");
    }

    const delay = ms => new Promise(res => setTimeout(res, ms));

    function create() {
        // keyboard detect
        cursors = this.input.keyboard.createCursorKeys();

        // Set Map
        createMap(this)

        // create animations
        pacmanAnimInit(this)
        ghostsAnimInit(this)

        // load in initial sprites
        for (let playerType in playerSprites) {
            const sprite = playerSprites[playerType]
            const defaultAnim = sprite.defaultAnim
            const startPos = sprite.startPos


            let tmp = this.physics.add.sprite(
                startPos[0],
                startPos[1],
                playerType === 'pcm' ? 'pacman' : 'ghosts'
            );

            tmp.anims.play(defaultAnim);
            tmp.setOrigin(0.5);
            tmp.setCollideWorldBounds(true);
            tmp.setScale(.7)
            // Set the width and height of the player sprite
            // tmp.displayWidth = 48; // Set width to 64 pixels
            // tmp.displayHeight = 48; // Set height to 64 pixels
            playerSprites[playerType].userNameTextPos = this.add.text(
                tmp.x - userNameOffSetX,
                tmp.y - userNameOffSetY, '', {
                    fontFamily: 'Arial',
                    fontSize: 12,
                    color: '#ffffff'
                });

            if (playerType === 'pcm') {
                // if pacman
                this.physics.add.collider(tmp, pelletLayer, pelletCallBack)
                this.physics.add.collider(tmp, powerLayer, powerUpCallBack)
            } else {
                // if ghosts collide with pacman
                this.physics.add.collider(tmp, playerSprites['pcm'].playerInfo, killPacmanCallBack)
            }

            this.physics.add.collider(tmp, mapLayer)

            tmp.id = playerType
            // attach player info
            playerSprites[playerType].playerInfo = tmp
        }

        // Set up the "Game Ended" text
        const textStyle = {fontFamily: 'Arial', fontSize: 48, color: '#ffffff'};
        gameOverText = this.add.text(200, 200, 'Game Ended', textStyle);
        gameOverText.setOrigin(0.5);
        gameOverText.visible = false; // Initially hide the text

        // update map to match game state till now
        for (const pelletId of prevGameState.pelletsEaten) {
            pelletLayer.removeTileAt(pelletId[0], pelletId[1])
        }

        for (const powerUpId of prevGameState.powerUpsEaten) {
            pelletLayer.removeTileAt(powerUpId[0], powerUpId[1])
        }

        for (const ghId of prevGameState.ghostsEaten) {
            playerSprites[ghId].playerInfo.destroy()
        }
    }

    function powerUpCheck() {
        if (playerSprites['pcm'].isPoweredUp > 0 || playerSprites['pcm'].isPoweredUp > 1200) {
            // time left till powerup
            playerSprites['pcm'].isPoweredUp -= 1
            playerSprites['pcm'].playerInfo.tint = 0xff0000;
            playerSprites['pcm'].movementSpeed = -160
        } else {
            playerSprites['pcm'].playerInfo.tint = 0xffffff; // Reset tint to white (no tint)
            playerSprites['pcm'].movementSpeed = -200
        }
    }

    function movePlayer(currentPlayerSpriteType, x = 0, y = 0) {
        if (playerSprites[currentPlayerSpriteType].playerInfo.active) {
            playerSprites[currentPlayerSpriteType].playerInfo.setVelocityY(y);
            playerSprites[currentPlayerSpriteType].playerInfo.setVelocityX(x);
        }
    }

    function update() {
        powerUpCheck();

        if (gameEnd) {
            // Show the "Game Ended" text
            gameOverText.visible = true;

            if (isRedirecting) {
                delay(2000).then(value => {
                    window.location.href = '/lobby';
                    // here so the game doesn't repeatedly redirect
                    isRedirecting = false
                })
            }

            // Prevent further updates
            this.input.off('pointerdown'); // Remove the event listener to avoid multiple redirects
            return;
        }

        const tmp = allPlayers[userId]
        // initial empty because websocket is requesting info
        if (tmp === undefined) {
            console.log(`waiting for player ${userId}`)
            return
        }

        let currentPlayerSpriteType = allPlayers[userId].spriteType
        // anims
        const neutralAnim = playerSprites[currentPlayerSpriteType].defaultAnim
        const anim = playerSprites[currentPlayerSpriteType].animBase
        let curAnim;

        if (cursors.left.isDown) {
            // remove vertical velocity
            movePlayer(currentPlayerSpriteType, playerSprites[currentPlayerSpriteType].movementSpeed, 0);
            // set anim
            curAnim = `${anim}West`
            setSpriteAnim(playerSprites[currentPlayerSpriteType].playerInfo, curAnim)

        } else if (cursors.right.isDown) {
            // remove vertical velocity
            movePlayer(currentPlayerSpriteType, -playerSprites[currentPlayerSpriteType].movementSpeed, 0);

            curAnim = `${anim}East`
            setSpriteAnim(playerSprites[currentPlayerSpriteType].playerInfo, curAnim)
        } else if (cursors.up.isDown) {
            // remove horizontal velocity
            movePlayer(currentPlayerSpriteType, 0, playerSprites[currentPlayerSpriteType].movementSpeed);

            curAnim = `${anim}North`
            setSpriteAnim(playerSprites[currentPlayerSpriteType].playerInfo, curAnim)
        } else if (cursors.down.isDown) {
            // remove horizontal velocity
            movePlayer(currentPlayerSpriteType, 0, -playerSprites[currentPlayerSpriteType].movementSpeed);

            curAnim = `${anim}South`
            setSpriteAnim(playerSprites[currentPlayerSpriteType].playerInfo, curAnim)
        } else {
            playerSprites[currentPlayerSpriteType].playerInfo.setVelocityY(0);
            playerSprites[currentPlayerSpriteType].playerInfo.setVelocityX(0);

            curAnim = neutralAnim
            setSpriteAnim(playerSprites[currentPlayerSpriteType].playerInfo, curAnim, false)
        }

        // move username text
        setUserNameTextPos(currentPlayerSpriteType)

        // setup info to send to server
        allPlayers[userId].x = playerSprites[currentPlayerSpriteType].playerInfo.x
        allPlayers[userId].y = playerSprites[currentPlayerSpriteType].playerInfo.y
        allPlayers[userId].spriteAnim = curAnim

        socket.emit('pos', JSON.stringify(allPlayers[userId]))
    }

    function setSpriteAnim(sprite, anim, loop = true) {
        // convert loop to bool
        sprite.anims.play(anim, loop)
    }

    function pelletCallBack(pacman, pellet) {
        socket.emit('pellet', JSON.stringify({user: userId, x: pellet.x, y: pellet.y}))
        // console.log(pelletLayer.tilesDrawn)
    }

    function powerUpCallBack(pacman, powerUp) {
        socket.emit('power', JSON.stringify({user: userId, x: powerUp.x, y: powerUp.y}))
        // console.log(pelletLayer.tilesDrawn)
    }

    function killPacmanCallBack(ghost, pacman) {
        // tell all clients pacman is dead
        socket.emit('pacded', JSON.stringify({user: userId, id: ghost.id}))
    }

    function setUserNameTextPos(spriteId) {
        playerSprites[spriteId].userNameTextPos.setText(playerSprites[spriteId]?.username);
        playerSprites[spriteId]
            .userNameTextPos
            .setPosition(
                playerSprites[spriteId].playerInfo.x - userNameOffSetX,
                playerSprites[spriteId].playerInfo.y - userNameOffSetY
            );
    }

    function setUserNameText(spriteId, text) {
        if (playerSprites[spriteId].userNameTextPos === null) {
            console.log('Client is not ready yet to set username text')
            return
        }
        playerSprites[spriteId].userNameTextPos.setText(text);
    }

    function pacmanAnimInit(ctx) {
        let namesArray = [
            'pacmanEast',
            'pacmanNorth',
            'pacmanSouth',
            'pacmanWest',
        ]
        let indexArray = 0
        for (let i = 0; i < 12; i += 3) {
            ctx.anims.create({
                frames: ctx.anims.generateFrameNumbers('pacman', {start: i + 1, end: i + 3}),
                key: namesArray[indexArray],
                frameRate: 10,
                repeat: -1
            });
            indexArray++
        }

        // neutral pacman
        ctx.anims.create({
            frames: ctx.anims.generateFrameNumbers('pacman', {start: 0, end: 0}),
            key: 'pacmanDefault',
            frameRate: 1,
            repeat: -1
        });

    }

    function createMap(ctx) {
        const map = ctx.make.tilemap({key: 'map'})

        const blueTile = map.addTilesetImage('secondTile', 'secondTile')
        const redTile = map.addTilesetImage('forthTile', 'forthTile')
        const pellets = map.addTilesetImage('centrepoint', 'centrepoint')
        const powerUp = map.addTilesetImage('power-up', 'power-up')

        mapLayer = map.createLayer('map', [blueTile, redTile])
        pelletLayer = map.createLayer('pellets', pellets)
        powerLayer = map.createLayer('powerup', powerUp)

        if (mapLayer === null || pelletLayer === null || powerLayer == null) {
            throw Error('Map layer or pellet layer failed to initlize')
        }

        mapLayer.setCollisionByExclusion([-1], true, true)
        pelletLayer.setCollisionByExclusion([-1])
        powerLayer.setCollisionByExclusion([-1])
    }

    function ghostsAnimInit(ctx) {
        let namesArray = [
            'ghostRedEast',
            'ghostRedNorth',
            'ghostRedSouth',
            'ghostRedWest',
            'ghostBlueEast',
            'ghostBlueNorth',
            'ghostBlueSouth',
            'ghostBlueWest',
            'ghostPinkEast',
            'ghostPinkNorth',
            'ghostPinkSouth',
            'ghostPinkWest',
            'frigthenedAnim',
        ]
        for (let i = 0; i < namesArray.length; i++) {
            ctx.anims.create({
                frames: ctx.anims.generateFrameNumbers('ghosts', {start: i, end: i}),
                key: namesArray[i],
            })
        }
    }


</script>

<div id="thegame"></div>

</body>
</html>`